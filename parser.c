#include <stdio.h>
#include <stdlib.h>
#include "parser.h"
#include "front.h"

static void error();

/**
 * This is the example Recursive-Descent Parser in pp. 181 - 185 in the 
 * textbook 
 *
 * Sebesta, R. W. (2012). Concepts of Programming Languages. 
 * Pearson, 10th edition.
 *
 *
 * */

/* expr
 * Parses strings in the language generated by the rule:
 * <expr> -> <term> {(+ | -) <term>}
 */
void parser(){
    stmt();
}

void stmt(){
    printf("Enter <stmt>\n");
    if(nextToken == IDENT){ // handle the assigning of variable statements
        lex();
        if(nextToken == ASSIGN_OP){
            lex();
            expr();
            }
        
        else{
            error();
        }
    }
    else if(nextToken == INC_OP || nextToken == DEC_OP){ // increase and decrease operators handled here
        lex();
        if(nextToken == IDENT){
            lex();
        }
        else{
            error();
        }
    }
    else if(nextToken == KEY_READ){// handle the read statement 
        lex();
        if(nextToken == LEFT_PAREN){
            lex();
            if(nextToken == IDENT){
                lex();
                if(nextToken == RIGHT_PAREN){
                    lex();

                }
                else{
                    error();
                }
            }
            else{
                error();
            }
        }
        else{
            error();
        }
    }
    else if(nextToken == KEY_PRINT){ //handle the print statement parsing
        lex();
        if(nextToken == LEFT_PAREN){
            lex();
            expr();
            if(nextToken == RIGHT_PAREN){
                lex();
            }
            else{
                error();
            }
        }
        else{
            error();
        }
    }
    else if(nextToken == KEY_IF){ //nested if else statements to handle the two possible routes of if stmts producing an error if it goes off track
        lex();
        cmpr();
        if(nextToken == COLON){
            lex();
            if(nextToken == KEY_BEGIN){
                lex();
                stmt(); 
                if(nextToken == KEY_ELSE){
                    lex();
                    if(nextToken == COLON){
                        lex();
                        stmt();
                        if(nextToken == KEY_END){
                            lex();
                        }
                        else{
                            error();
                        }
                    }
                    else{
                        error();
                    }
                }
                else if(nextToken == KEY_END){
                    lex();
                }
                else{
                    error();
                }
            }
            else{
                error();
            }
        }
        else{
            error();
        }
    }
    else{ //if something wonky that's incorrect it will default to an error
        error();
    }
   if(nextToken == SEMICOLON){ // check semicolon after stmt is parsed
        lex();
        if(nextToken == KEY_END){ // to handle end; possibilities
            lex();
            if(nextToken == SEMICOLON){ //to stop parsing if "end;" appears
                error();
            }
        }
        else if(nextToken != EOF){ // to continue on for the form S; S
            stmt();
        }
}
}

void cmpr(){ //comparison statements function 
    expr();
    if(nextToken == LESSER_OP || nextToken == GREATER_OP || nextToken == EQUAL_OP || nextToken == NEQUAL_OP || nextToken == LEQUAL_OP || nextToken == GEQUAL_OP){
        lex();
        expr();
    }
    else{
        error();    
    }
}
/*void oper(){
    printf("Enter <O>\n");
    if(nextToken == INC_OP || nextToken == DEC_OP){
        lex();
        factor();
    }
    printf("Exit <O>\n");
}*/
void expr() 
{
    printf("Enter <expr>\n");

    /* Parse the first term */
    term();

    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP) {
        lex();
        term();
    }

    printf("Exit <expr>\n");
} /* End of function expr */

/* term
 * Parses strings in the language generated by the rule:
 * <term> -> <factor> {(* | /) <factor>)
 */
void term()                     
{
    printf("Enter <term>\n");
    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP || nextToken == POW_OP) {
            lex();
            factor();
    }
    printf("Exit <term>\n");
} /* End of function term */

/* factor
 * Parses strings in the language generated by the rule:
 * <factor> -> id | int_constant | ( <expr )
 * */
void factor() {
    printf("Enter <factor>\n");
    /* Determine which RHS */
    if (nextToken == IDENT || nextToken == INT_LIT) {
        lex(); /* Get the next token */
    } else {
        /* If the RHS is (<expr>), call lex to pass over the 
        left parenthesis, call expr, and check for the right 
        parenthesis */
        if (nextToken == LEFT_PAREN) {
            lex(); 
            expr();

            if (nextToken == RIGHT_PAREN) {
                lex(); 
            } else { 
                error();
            }
        } /* End of if (nextToken == ... */
        /* It was not an id, an integer literal, or a left parenthesis */
        else 
        { 
            error(); 
        }
    } /* End of else */
    printf("Exit <factor>\n");;
} /* End of function factor */

static void error() 
{ 
    printf("Error encounter on line %d: The next lexeme was %s and the next token was %s\n", line_count, lexeme, toke);
    exit(1);
}
